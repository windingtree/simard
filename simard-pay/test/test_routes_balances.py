from flask_testing import TestCase
from simard import app
from unittest import mock
from decimal import Decimal
from simard.db import db
import mongomock
from bson.decimal128 import Decimal128
import uuid
from model.exception import SimardException
from simard.settings import VIRTUAL_CARD_ORGID, GLIDER_B2B_ORGID
from simard.guarantee import Guarantee


class BalanceRouteTest(TestCase):
    def setUp(self):
        db._database = mongomock.MongoClient().unittest

        # JWT Token is fake since we mock the call to the token verification
        self.jwt = '<header>.<claim>.<signature>'
        self.headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'Authorization': 'Bearer %s' % self.jwt
        }

        self.orgid = '0x0000000000000000000000000000000000000000000000000000000000001121'
        self.agent = 'did:orgid:%s#secondkey' % self.orgid
        self.currency = 'EUR'

        # Mock the token to avoid making external calls
        # Can be overriden with self.mock_validate_token.return_value
        patcher = mock.patch(
            'simard.oauth_manager.OAuthManager.validate_token',
            return_value=(self.orgid, self.agent)
        )
        self.mock_validate_token = patcher.start()
        self.addCleanup(patcher.stop)

        # A Patcher for the event handler
        event_handler_patcher = mock.patch('simard.event_handler.EventHandler.log_event')
        self.mock_event_handler = event_handler_patcher.start()
        self.addCleanup(event_handler_patcher.stop)

    # Create the app
    def create_app(self):
        app.config['TESTING'] = True
        return app

    def test_authentication_bearer_missing(self):
        """
        Test a call with missing header
        """
        response = self.client.get(
            path='/api/v1/balances',
            headers={
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }
        )

        # Check the result
        self.assert403(response)
        self.assertEqual(response.json, {
            "message": "Authentication Bearer missing"
        })

    def test_authentication_generating_exception(self):
        """
        Test a call where the server fails
        """
        self.mock_validate_token.side_effect = Exception('Boom!')
        response = self.client.get(
            path='/api/v1/balances',
            headers=self.headers
        )

        # Check the result
        self.assert500(response)
        self.assertEqual(response.json, {
            "message": "Server Error: Please contact support"
        })

        self.assertTrue(self.mock_event_handler.called)

    def test_authentication_failing(self):
        """
        Test a call where an exception is generated by Simard when valdidating token
        """
        self.mock_validate_token.side_effect = SimardException('NOT VALIDATED', 400)
        response = self.client.get(
            path='/api/v1/balances',
            headers=self.headers
        )

        # Check the result
        self.assert403(response)
        self.assertEqual(response.json, {
            "message": "Authentication refused: NOT VALIDATED | Token: %s" % self.jwt
        })

    def test_get_balances_empty(self):
        """
        Test for a first run the balance is zero
        """
        with mock.patch('simard.balance_manager.BalanceManager.get_balances') as gb:
            # Create a fake answer to the get_balances call
            gb.return_value = []

            # Get the balances
            response = self.client.get(
                path='/api/v1/balances',
                headers=self.headers
            )

        # Check the result
        self.assert200(response)
        self.assertEqual(response.json, {})

        # Check the token was verified
        self.mock_validate_token.assert_called_once_with(self.jwt)

    def test_get_balances_one(self):
        """
        Test for a first run the balance is zero
        """
        with mock.patch('simard.balance_manager.BalanceManager.get_balances') as gb:
            # Create a fake answer to the get_balances call
            mock_balance = mock.MagicMock()
            mock_balance.currency = 'EUR'
            mock_balance.available = Decimal('240.00')
            mock_balance.reserved = Decimal('260.00')
            mock_balance.total = Decimal('500.00')
            gb.return_value = [mock_balance]

            # Get the balances
            response = self.client.get(
                path='/api/v1/balances',
                headers=self.headers
            )

        self.assert200(response)
        self.assertEqual(response.json, {
            'EUR': {
                'available': '240.00',
                'reserved': '260.00',
                'total': '500.00'
            }
        })
        gb.assert_called_once_with(self.orgid)

    def test_get_balances_multiple(self):
        """
        Test to retrieve a balance with multiple currencues
        """
        with mock.patch('simard.balance_manager.BalanceManager.get_balances') as gb:
            # Create a fake answer to the get_balances call
            gb.return_value = []
            for currency in ['EUR', 'USD', 'CHF', 'GBP']:
                mock_balance = mock.MagicMock()
                mock_balance.currency = currency
                mock_balance.available = Decimal('900.00')
                mock_balance.reserved = Decimal('100.00')
                mock_balance.total = Decimal('1000.00')
                gb.return_value.append(mock_balance)

            # Get the balances
            response = self.client.get(
                path='/api/v1/balances',
                headers=self.headers
            )

        self.assert200(response)
        self.assertEqual(response.json, {
            'EUR': {
                'available': '900.00',
                'reserved': '100.00',
                'total': '1000.00'
            },
            'USD': {
                'available': '900.00',
                'reserved': '100.00',
                'total': '1000.00'
            },
            'CHF': {
                'available': '900.00',
                'reserved': '100.00',
                'total': '1000.00'
            },
            'GBP': {
                'available': '900.00',
                'reserved': '100.00',
                'total': '1000.00'
            }
        })
        gb.assert_called_once_with(self.orgid)

    def test_create_guarantee(self):
        """
        Test to create a guarantee
        """
        beneficiary = \
            "0x0000000000000000000000000000000000000000000000000000000000005121"

        with mock.patch(
            'simard.balance.Balance.available',
            new_callable=mock.PropertyMock
        ) as ma:
            # Redefine the return value
            ma.return_value = Decimal('5000.00')

            # Get the balances
            response = self.client.post(
                path='/api/v1/balances/guarantees',
                json={
                    "currency": "EUR",
                    "amount": "300.00",
                    "creditorOrgId": beneficiary,
                    "expiration": "2052-03-30T13:37:38Z"
                },
                headers=self.headers
            )

        # Check the response
        self.assert200(response)
        self.assertEqual(len(response.json.keys()), 1)
        guarantee_uuid = response.json['guaranteeId']
        self.assertIsNotNone(guarantee_uuid)

        # Check the guarantee is created in DB
        g1 = db._database.guarantees.find_one({'uuid': guarantee_uuid})
        self.assertEqual(g1['initiator'], self.orgid)
        self.assertEqual(g1['beneficiary'], beneficiary)
        self.assertEqual(g1['amount'], Decimal128('300.00'))
        self.assertEqual(g1['currency'], 'EUR')
        self.assertEqual(g1['agent'], self.agent)
        self.assertEqual(g1['expiration'], "2052-03-30T13:37:38+00:00")

        # Retrieve the guarantee
        response = self.client.get(
            path='/api/v1/balances/guarantees/%s' % guarantee_uuid,
            headers=self.headers
        )
        self.assert200(response)
        self.assertEqual(response.json, {
            "currency": "EUR",
            "amount": "300.00",
            "creditorOrgId": beneficiary,
            'debtorOrgId': self.orgid,
            "expiration": "2052-03-30T13:37:38Z"
        })

    def test_create_guarantee_missing_key(self):
        """
        Test to create a guarantee with a missing key
        """
        beneficiary = \
            "0x0000000000000000000000000000000000000000000000000000000000005121"

        # Get the balances
        response = self.client.post(
            path='/api/v1/balances/guarantees',
            json={
                "currency": "EUR",
                "amount": "300.00",
                "creditorOrgId": beneficiary,
            },
            headers=self.headers
        )

        # Check the response
        self.assert400(response)
        self.assertEqual(response.json, {
            'message': 'Missing mandatory key in parameters: expiration'
        })

    def test_get_guarantee_random(self):
        """
        Test to retrieve a guarantee that does not exist
        """
        response = self.client.get(
            path='/api/v1/balances/guarantees/%s' % str(uuid.uuid4()),
            headers=self.headers
        )
        self.assert404(response)
        self.assertEqual(response.json, {
            'message': 'Guarantee not found'
        })

    def test_guarantee_create_delete(self):
        """
        Test to create a guarantee and delete it
        """
        beneficiary = \
            "0x0000000000000000000000000000000000000000000000000000000000005121"

        # Get the balances
        with mock.patch(
            'simard.balance.Balance.available',
            new_callable=mock.PropertyMock
        ) as ma:
            # Redefine the return value
            ma.return_value = Decimal('5000.00')
            guarantee_uuid = self.client.post(
                path='/api/v1/balances/guarantees',
                json={
                    "currency": "EUR",
                    "amount": "300.00",
                    "creditorOrgId": beneficiary,
                    "expiration": "2052-03-30T13:37:38Z"
                },
                headers=self.headers
            ).json['guaranteeId']

        # Check that the delete fails
        response = self.client.delete(
            path='/api/v1/balances/guarantees/%s' % guarantee_uuid,
            headers=self.headers
        )
        self.assert400(response)
        self.assertEqual(response.json, {
            'message': 'Guarantee cannot be canceled before it expires'
        })

        # Now fast forward
        db._database.guarantees.update_one(
            {'uuid': guarantee_uuid},
            {"$set": {"expiration": "2019-03-30T13:37:38Z"}},
            upsert=True
        )

        # Check that the delete now works
        response = self.client.delete(
            path='/api/v1/balances/guarantees/%s' % guarantee_uuid,
            headers=self.headers
        )
        self.assert200(response)
        self.assertEqual(response.json, {})

    def test_guarantee_create_claim(self):
        """
        Test to create a guarantee and claim it
        """
        beneficiary = \
            "0x0000000000000000000000000000000000000000000000000000000000005121"

        # Create a guarantee
        with mock.patch(
            'simard.balance.Balance.available',
            new_callable=mock.PropertyMock
        ) as ma:
            # Redefine the return value
            ma.return_value = Decimal('5000.00')
            guarantee_uuid = self.client.post(
                path='/api/v1/balances/guarantees',
                json={
                    "currency": "EUR",
                    "amount": "300.00",
                    "creditorOrgId": beneficiary,
                    "expiration": "2052-03-30T13:37:38Z"
                },
                headers=self.headers
            ).json['guaranteeId']

        # Switch the ORG.ID
        self.mock_validate_token.return_value = (beneficiary, self.agent + "BENEF")

        # Claim the guarantee
        response = self.client.post(
            path='/api/v1/balances/guarantees/%s/claim' % guarantee_uuid,
            headers=self.headers
        )

        self.assert200(response)
        self.assertEqual(len(response.json.keys()), 1)
        self.assertIsNotNone(response.json['settlementId'])
        settlement_uuid = response.json['settlementId']

        # Retrieve the settlement
        s = db._database.settlements.find_one({
            'uuid': settlement_uuid
        })
        self.assertEqual(s['initiator'], self.orgid)
        self.assertEqual(s['beneficiary'], beneficiary)
        self.assertEqual(s['amount'], Decimal128('300.00'))
        self.assertEqual(s['currency'], 'EUR')
        self.assertEqual(s['agent'], self.agent + "BENEF")
        self.assertEqual(s['guarantee'], guarantee_uuid)

    def test_guarantee_create_claim_with_card(self):
        """
        Test to create a guarantee and claim with Virtual CC
        """
        beneficiary = \
            GLIDER_B2B_ORGID

        # Create a guarantee
        with mock.patch(
            'simard.balance.Balance.available',
            new_callable=mock.PropertyMock
        ) as ma:
            # Redefine the return value
            ma.return_value = Decimal('5000.00')
            guarantee_uuid = self.client.post(
                path='/api/v1/balances/guarantees',
                json={
                    "currency": "EUR",
                    "amount": "300.00",
                    "creditorOrgId": beneficiary,
                    "expiration": "2052-03-30T13:37:38Z"
                },
                headers=self.headers
            ).json['guaranteeId']

        # Switch the ORG.ID
        self.mock_validate_token.return_value = (beneficiary, self.agent + "BENEF")

        # Claim the guarantee with an expiration in the past
        response_past = self.client.post(
            path='/api/v1/balances/guarantees/%s/claimWithCard' % guarantee_uuid,
            json={
                "expiration": "2019-03-06T14:19:05.678Z"
            },
            headers=self.headers
        )

        self.assertEqual(response_past.json, {
            'message': 'Expiration datetime is in the past'
        })
        self.assert400(response_past)
        self.assertFalse(Guarantee.from_storage(guarantee_uuid).claimed)

        # Claim the guarantee with a date in the future
        with mock.patch(
            'simard.balance.Balance.available',
            new_callable=mock.PropertyMock
        ) as ma:
            # Redefine the return value
            ma.return_value = Decimal('5000.00')
            response = self.client.post(
                path='/api/v1/balances/guarantees/%s/claimWithCard' % guarantee_uuid,
                json={
                    "expiration": "2059-03-06T14:19:05.678Z"
                },
                headers=self.headers
            )
        print(response.json)
        self.assert200(response)
        self.assertEqual(len(response.json.keys()), 2)
        self.assertIsNotNone(response.json['settlementId'])
        settlement_uuid = response.json['settlementId']

        # Retrieve the settlement
        s = db._database.settlements.find_one({
            'uuid': settlement_uuid
        })
        self.assertEqual(s['initiator'], self.orgid)
        self.assertEqual(s['beneficiary'], beneficiary)
        self.assertEqual(s['amount'], Decimal128('300.00'))
        self.assertEqual(s['currency'], 'EUR')
        self.assertEqual(s['agent'], self.agent + "BENEF")
        self.assertEqual(s['guarantee'], guarantee_uuid)

        # Retrieve the guarantee for the card
        card_guarantee_id = response.json['card']['id']
        self.assertNotEqual(guarantee_uuid, card_guarantee_id)

        # Check the guarantee
        g1 = db._database.guarantees.find_one({'uuid': response.json['card']['id']})
        self.assertEqual(g1['initiator'], beneficiary)
        self.assertEqual(g1['beneficiary'], VIRTUAL_CARD_ORGID)
        self.assertEqual(g1['amount'], Decimal128('300.00'))
        self.assertEqual(g1['currency'], 'EUR')
        self.assertEqual(g1['agent'], self.agent + "BENEF")
        self.assertEqual(g1['expiration'], "2059-03-06T14:19:05.678000+00:00")

        # Check the card details
        self.assertEqual(response.json['card'], {
            'id': card_guarantee_id,
            'accountNumber': '4444333322221111',
            'cvv': '737',
            'expiryMonth': '10',
            'expiryYear': '2020',
            'type': 'debit',
            'brand': 'visa'
        })

        # Check that this guarantee can now be claimed by Simard
        self.mock_validate_token.return_value = (
            VIRTUAL_CARD_ORGID,
            self.agent + "VCC"
        )
        response = self.client.post(
            path='/api/v1/balances/guarantees/%s/claim' % card_guarantee_id,
            headers=self.headers
        )

        self.assert200(response)
        self.assertEqual(len(response.json.keys()), 1)
        card_settlement_uuid = response.json['settlementId']
        self.assertIsNotNone(card_settlement_uuid)
        self.assertNotEqual(settlement_uuid, card_settlement_uuid)

        # Retrieve the settlement
        s = db._database.settlements.find_one({
            'uuid': card_settlement_uuid
        })
        self.assertEqual(s['initiator'], beneficiary)
        self.assertEqual(s['beneficiary'], VIRTUAL_CARD_ORGID)
        self.assertEqual(s['amount'], Decimal128('300.00'))
        self.assertEqual(s['currency'], 'EUR')
        self.assertEqual(s['agent'], self.agent + "VCC")
        self.assertEqual(s['guarantee'], card_guarantee_id)

    def test_deposit_and_withdraw(self):
        """
        Test to simulate a deposit
        """
        response = self.client.post(
            path='/api/v1/balances/simulateDeposit',
            headers=self.headers,
            json={
                "currency": self.currency,
                "amount": "12500.00"
            }
        )
        print(response.json)
        self.assert200(response)
        self.assertEqual(len(response.json.keys()), 1)
        siulation_settlement_uuid = response.json['settlementId']

        # Retrieve the settlement
        s = db._database.settlements.find_one({
            'uuid': siulation_settlement_uuid
        })
        self.assertEqual(s['initiator'], 'faucet')
        self.assertEqual(s['beneficiary'], self.orgid)
        self.assertEqual(s['amount'], Decimal128('12500.00'))
        self.assertEqual(s['currency'], self.currency)
        self.assertEqual(s['agent'], self.agent)

        # Now withdraw
        with mock.patch(
            'simard.balance.Balance.available',
            new_callable=mock.PropertyMock
        ) as ma:
            # Redefine the balance
            ma.return_value = Decimal('5000.00')
            with \
                mock.patch('simard.account_manager.AccountManager.get_accounts') \
                    as ga:
                # Redefine the accounts
                account = mock.Mock()
                account.currency = self.currency
                ga.return_value = [account]

                # Withdraw
                response = self.client.post(
                    path='/api/v1/balances/%s/withdraw' % self.currency,
                    headers=self.headers,
                )

        self.assert200(response)
        self.assertIsNotNone(response.json['settlementId'])
        settlement_uuid = response.json['settlementId']

        # Retrieve the settlement
        s2 = db._database.settlements.find_one({
            'uuid': settlement_uuid
        })
        self.assertEqual(s2['initiator'], self.orgid)
        self.assertEqual(s2['beneficiary'], 'Bank Transfer')
        self.assertEqual(s2['amount'], Decimal128('5000.00'))
        self.assertEqual(s2['currency'], self.currency)
        self.assertEqual(s2['agent'], self.agent)
